{"version":3,"sources":["History.js"],"names":["define","langx","_","Backbone","events","helper","History","BackboneEvented","inherit","_construct","this","handlers","checkUrl","bind","window","location","history","routeStripper","rootStripper","pathStripper","started","partial","interval","atRoot","pathname","replace","root","getSearch","matchRoot","decodeFragment","slice","length","fragment","decodeURI","match","href","getHash","getPath","path","charAt","getFragment","_usePushState","_wantsHashChange","start","options","Error","extend","hashChange","_hasHashChange","document","documentMode","_useHashChange","_wantsPushState","pushState","_hasPushState","rootPath","navigate","iframe","createElement","src","style","display","tabIndex","body","iWindow","insertBefore","firstChild","contentWindow","open","close","hash","addEventListener","eventName","listener","attachEvent","_checkUrlInterval","setInterval","silent","loadUrl","stop","removeEventListener","detachEvent","removeChild","clearInterval","route","callback","unshift","e","current","some","handler","test","trigger","url","title","assign","_updateHash"],"mappings":"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","file":"../History.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"skylark-underscore/underscore\",\r\n  \"./backbone\",\r\n  \"./events\",\r\n  \"./helper\"\r\n],function(langx,_,Backbone,events,helper){\r\n\r\n // Backbone.History\r\n  // ----------------\r\n\r\n  // Handles cross-browser history management, based on either\r\n  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n  // and URL fragments. If the browser supports neither (old IE, natch),\r\n  // falls back to polling.\r\n  var History = Backbone.History = events.BackboneEvented.inherit({\r\n    _construct : function() {\r\n        this.handlers = [];\r\n        this.checkUrl = _.bind(this.checkUrl, this);\r\n    \r\n        // Ensure that `History` can be used outside of the browser.\r\n        if (typeof window !== 'undefined') {\r\n          this.location = window.location;\r\n          this.history = window.history;\r\n        }\r\n    }\r\n  });\r\n\r\n  // Cached regex for stripping a leading hash/slash and trailing space.\r\n  var routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n  // Cached regex for stripping leading and trailing slashes.\r\n  var rootStripper = /^\\/+|\\/+$/g;\r\n\r\n  // Cached regex for stripping urls of hash.\r\n  var pathStripper = /#.*$/;\r\n\r\n  // Has the history handling already been started?\r\n  History.started = false;\r\n\r\n  // Set up all inheritable **Backbone.History** properties and methods.\r\n  History.partial({\r\n\r\n    // The default interval to poll for hash changes, if necessary, is\r\n    // twenty times a second.\r\n    interval: 50,\r\n\r\n    // Are we at the app root?\r\n    atRoot: function() {\r\n      var path = this.location.pathname.replace(/[^\\/]$/, '$&/');\r\n      return path === this.root && !this.getSearch();\r\n    },\r\n\r\n    // Does the pathname match the root?\r\n    matchRoot: function() {\r\n      var path = this.decodeFragment(this.location.pathname);\r\n      var rootPath = path.slice(0, this.root.length - 1) + '/';\r\n      return rootPath === this.root;\r\n    },\r\n\r\n    // Unicode characters in `location.pathname` are percent encoded so they're\r\n    // decoded for comparison. `%25` should not be decoded since it may be part\r\n    // of an encoded parameter.\r\n    decodeFragment: function(fragment) {\r\n      return decodeURI(fragment.replace(/%25/g, '%2525'));\r\n    },\r\n\r\n    // In IE6, the hash fragment and search params are incorrect if the\r\n    // fragment contains `?`.\r\n    getSearch: function() {\r\n      var match = this.location.href.replace(/#.*/, '').match(/\\?.+/);\r\n      return match ? match[0] : '';\r\n    },\r\n\r\n    // Gets the true hash value. Cannot use location.hash directly due to bug\r\n    // in Firefox where location.hash will always be decoded.\r\n    getHash: function(window) {\r\n      var match = (window || this).location.href.match(/#(.*)$/);\r\n      return match ? match[1] : '';\r\n    },\r\n\r\n    // Get the pathname and search params, without the root.\r\n    getPath: function() {\r\n      var path = this.decodeFragment(\r\n        this.location.pathname + this.getSearch()\r\n      ).slice(this.root.length - 1);\r\n      return path.charAt(0) === '/' ? path.slice(1) : path;\r\n    },\r\n\r\n    // Get the cross-browser normalized URL fragment from the path or hash.\r\n    getFragment: function(fragment) {\r\n      if (fragment == null) {\r\n        if (this._usePushState || !this._wantsHashChange) {\r\n          fragment = this.getPath();\r\n        } else {\r\n          fragment = this.getHash();\r\n        }\r\n      }\r\n      return fragment.replace(routeStripper, '');\r\n    },\r\n\r\n    // Start the hash change handling, returning `true` if the current URL matches\r\n    // an existing route, and `false` otherwise.\r\n    start: function(options) {\r\n      if (History.started) throw new Error('Backbone.history has already been started');\r\n      History.started = true;\r\n\r\n      // Figure out the initial configuration. Do we need an iframe?\r\n      // Is pushState desired ... is it available?\r\n      this.options          = _.extend({root: '/'}, this.options, options);\r\n      this.root             = this.options.root;\r\n      this._wantsHashChange = this.options.hashChange !== false;\r\n      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);\r\n      this._useHashChange   = this._wantsHashChange && this._hasHashChange;\r\n      this._wantsPushState  = !!this.options.pushState;\r\n      this._hasPushState    = !!(this.history && this.history.pushState);\r\n      this._usePushState    = this._wantsPushState && this._hasPushState;\r\n      this.fragment         = this.getFragment();\r\n\r\n      // Normalize root to always include a leading and trailing slash.\r\n      this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n      // Transition from hashChange to pushState or vice versa if both are\r\n      // requested.\r\n      if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n        // If we've started off with a route from a `pushState`-enabled\r\n        // browser, but we're currently in a browser that doesn't support it...\r\n        if (!this._hasPushState && !this.atRoot()) {\r\n          var rootPath = this.root.slice(0, -1) || '/';\r\n          this.location.replace(rootPath + '#' + this.getPath());\r\n          // Return immediately as browser will do redirect to new url\r\n          return true;\r\n\r\n        // Or if we've started out with a hash-based route, but we're currently\r\n        // in a browser where it could be `pushState`-based instead...\r\n        } else if (this._hasPushState && this.atRoot()) {\r\n          this.navigate(this.getHash(), {replace: true});\r\n        }\r\n\r\n      }\r\n\r\n      // Proxy an iframe to handle location events if the browser doesn't\r\n      // support the `hashchange` event, HTML5 history, or the user wants\r\n      // `hashChange` but not `pushState`.\r\n      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {\r\n        this.iframe = document.createElement('iframe');\r\n        this.iframe.src = 'javascript:0';\r\n        this.iframe.style.display = 'none';\r\n        this.iframe.tabIndex = -1;\r\n        var body = document.body;\r\n        // Using `appendChild` will throw on IE < 9 if the document is not ready.\r\n        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;\r\n        iWindow.document.open();\r\n        iWindow.document.close();\r\n        iWindow.location.hash = '#' + this.fragment;\r\n      }\r\n\r\n      // Add a cross-platform `addEventListener` shim for older browsers.\r\n      var addEventListener = window.addEventListener || function(eventName, listener) {\r\n        return attachEvent('on' + eventName, listener);\r\n      };\r\n\r\n      // Depending on whether we're using pushState or hashes, and whether\r\n      // 'onhashchange' is supported, determine how we check the URL state.\r\n      if (this._usePushState) {\r\n        addEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        addEventListener('hashchange', this.checkUrl, false);\r\n      } else if (this._wantsHashChange) {\r\n        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);\r\n      }\r\n\r\n      if (!this.options.silent) return this.loadUrl();\r\n    },\r\n\r\n    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,\r\n    // but possibly useful for unit testing Routers.\r\n    stop: function() {\r\n      // Add a cross-platform `removeEventListener` shim for older browsers.\r\n      var removeEventListener = window.removeEventListener || function(eventName, listener) {\r\n        return detachEvent('on' + eventName, listener);\r\n      };\r\n\r\n      // Remove window listeners.\r\n      if (this._usePushState) {\r\n        removeEventListener('popstate', this.checkUrl, false);\r\n      } else if (this._useHashChange && !this.iframe) {\r\n        removeEventListener('hashchange', this.checkUrl, false);\r\n      }\r\n\r\n      // Clean up the iframe if necessary.\r\n      if (this.iframe) {\r\n        document.body.removeChild(this.iframe);\r\n        this.iframe = null;\r\n      }\r\n\r\n      // Some environments will throw when clearing an undefined interval.\r\n      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);\r\n      History.started = false;\r\n    },\r\n\r\n    // Add a route to be tested when the fragment changes. Routes added later\r\n    // may override previous routes.\r\n    route: function(route, callback) {\r\n      this.handlers.unshift({route: route, callback: callback});\r\n    },\r\n\r\n    // Checks the current URL to see if it has changed, and if it has,\r\n    // calls `loadUrl`, normalizing across the hidden iframe.\r\n    checkUrl: function(e) {\r\n      var current = this.getFragment();\r\n\r\n      // If the user pressed the back button, the iframe's hash will have\r\n      // changed and we should use that for comparison.\r\n      if (current === this.fragment && this.iframe) {\r\n        current = this.getHash(this.iframe.contentWindow);\r\n      }\r\n\r\n      if (current === this.fragment) return false;\r\n      if (this.iframe) this.navigate(current);\r\n      this.loadUrl();\r\n    },\r\n\r\n    // Attempt to load the current URL fragment. If a route succeeds with a\r\n    // match, returns `true`. If no defined routes matches the fragment,\r\n    // returns `false`.\r\n    loadUrl: function(fragment) {\r\n      // If the root doesn't match, no routes can match either.\r\n      if (!this.matchRoot()) return false;\r\n      fragment = this.fragment = this.getFragment(fragment);\r\n      return _.some(this.handlers, function(handler) {\r\n        if (handler.route.test(fragment)) {\r\n          handler.callback(fragment);\r\n          return true;\r\n        }\r\n      });\r\n    },\r\n\r\n    // Save a fragment into the hash history, or replace the URL state if the\r\n    // 'replace' option is passed. You are responsible for properly URL-encoding\r\n    // the fragment in advance.\r\n    //\r\n    // The options object can contain `trigger: true` if you wish to have the\r\n    // route callback be fired (not usually desirable), or `replace: true`, if\r\n    // you wish to modify the current URL without adding an entry to the history.\r\n    navigate: function(fragment, options) {\r\n      if (!History.started) return false;\r\n      if (!options || options === true) options = {trigger: !!options};\r\n\r\n      // Normalize the fragment.\r\n      fragment = this.getFragment(fragment || '');\r\n\r\n      // Don't include a trailing slash on the root.\r\n      var rootPath = this.root;\r\n      if (fragment === '' || fragment.charAt(0) === '?') {\r\n        rootPath = rootPath.slice(0, -1) || '/';\r\n      }\r\n      var url = rootPath + fragment;\r\n\r\n      // Strip the hash and decode for matching.\r\n      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));\r\n\r\n      if (this.fragment === fragment) return;\r\n      this.fragment = fragment;\r\n\r\n      // If pushState is available, we use it to set the fragment as a real URL.\r\n      if (this._usePushState) {\r\n        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n\r\n      // If hash changes haven't been explicitly disabled, update the hash\r\n      // fragment to store history.\r\n      } else if (this._wantsHashChange) {\r\n        this._updateHash(this.location, fragment, options.replace);\r\n        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {\r\n          var iWindow = this.iframe.contentWindow;\r\n\r\n          // Opening and closing the iframe tricks IE7 and earlier to push a\r\n          // history entry on hash-tag change.  When replace is true, we don't\r\n          // want this.\r\n          if (!options.replace) {\r\n            iWindow.document.open();\r\n            iWindow.document.close();\r\n          }\r\n\r\n          this._updateHash(iWindow.location, fragment, options.replace);\r\n        }\r\n\r\n      // If you've told us that you explicitly don't want fallback hashchange-\r\n      // based history, then `navigate` becomes a page refresh.\r\n      } else {\r\n        return this.location.assign(url);\r\n      }\r\n      if (options.trigger) return this.loadUrl(fragment);\r\n    },\r\n\r\n    // Update the hash location, either replacing the current entry, or adding\r\n    // a new one to the browser history.\r\n    _updateHash: function(location, fragment, replace) {\r\n      if (replace) {\r\n        var href = location.href.replace(/(javascript:|#).*$/, '');\r\n        location.replace(href + '#' + fragment);\r\n      } else {\r\n        // Some browsers require that `hash` contains a leading #.\r\n        location.hash = '#' + fragment;\r\n      }\r\n    }\r\n\r\n  });\r\n\r\n  // Create the default Backbone.history.\r\n  Backbone.history = new History;\r\n\r\n  // Set up inheritance for the model, collection, router, view and history.\r\n  History.extend = Backbone.extend ;\r\n\r\n\r\n  return History;\r\n\r\n});\r\n\r\n"]}