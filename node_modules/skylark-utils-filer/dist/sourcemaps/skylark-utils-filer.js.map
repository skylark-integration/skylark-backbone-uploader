{"version":3,"sources":["skylark-utils-filer.js"],"names":["define","skylark","filer","downlad","data","name","window","navigator","msSaveBlob","types","isString","dataURItoBlob","a","document","createElement","Blob","URL","createObjectURL","href","setAttribute","dispatchEvent","CustomEvent","arrays","Deferred","concat","Array","prototype","webentry","one","entry","path","d","onError","e","reject","isFile","file","relativePath","resolve","isDirectory","dirReader","createReader","readEntries","entries","all","then","files","catch","promise","map","apply","arguments","styler","eventer","dropzone","elm","params","hoverClass","droppedCallback","dropped","enterdCount","on","dataTransfer","indexOf","stop","addClass","removeClass","items","length","webkitGetAsEntry","getAsEntry","item","this","objects","pastezone","pastedCallback","pasted","originalEvent","clipboardData","each","index","getAsFile","push","fileInput","maxFileSize","select","directory","multiple","fileSelected","picked","input","selectFiles","pickedFiles","i","size","splice","type","style","position","left","top","opacity","body","appendChild","onchange","target","webkitEntries","slice","call","value","webkitdirectory","click","picker","preventDefault","read","readFile","reader","FileReader","onload","evt","result","onerror","code","error","alert","asArrayBuffer","readAsArrayBuffer","asDataUrl","readAsDataURL","asText","readAsText","Xhr","upload","xoptions","mixin","contentRange","paramName","undefined","singleFileUploads","limitMultiFileUploads","limitMultiFileUploadSize","limitMultiFileUploadSizeOverhead","sequentialUploads","limitConcurrentUploads","multipart","maxChunkSize","uploadedBytes","recalculateProgress","progressInterval","bitrateInterval","autoUpload","messages","i18n","message","context","toString","key","replace","formData","form","serializeArray","add","isDefaultPrevented","$","fileupload","process","done","submit","processData","contentType","cache","blobSlice","webkitSlice","mozSlice","ajax","request","url","initXHRData","o","headers","FormData","blob","append","uploadName","encodeURI","chunkedUpload","options","testOnly","jqXHR","fs","ub","mcs","dfd","_getXHRPromise","currentLoaded","_progress","loaded","chunkSize","textStatus","range","getResponseHeader","parts","split","upperBytesPos","parseInt","getUploadedBytes","progress","lengthComputable","total","resolveWith","fail","errorThrown","rejectWith","abort","_bitrateTimer","timestamp","Date","now","getTime","bitrate","getBitrate","interval","timeDiff","jqXhr","langx","FileUploader","Evented","inherit","dropZone","pasteZone","postMessage","option","_specialOptions","_BitrateTimer","_getTotal","_initProgressObject","obj","extend","_initResponseObject","prop","_response","hasOwnProperty","_onProgress","_time","Math","floor","_trigger","create","delegatedEvent","_getParamName","isArray","_getDeferredState","deferred","state","isResolved","isRejected","_enhancePromise","success","complete","always","resolveOrReject","args","_addConvenienceMethods","that","getPromise","resolveFunc","rejectFunc","_processQueue","pipe","_onSend","processing","response","_beforeSend","_active","_onDone","_onFail","event","proxy","trigger","_onAlways","jqXHRorResult","jqXHRorError","_sending","dataType","xhrFields","_onAdd","paramNameSet","paramNameSlice","fileSet","filesLength","limit","limitSize","overhead","batchSize","j","originalFiles","element","newData","_initEventHandlers","_destroyEventHandlers","_setOption","reinit","inArray","_super","_initSpecialOptions","_elm","_getRegExp","str","modifiers","pop","shift","RegExp","join","_isRegExpOption","test","_construct","_slots","_sequence","active","disabled","makeArray","send","uploader","fuInst","typ","isFunction","main"],"mappings":"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","file":"../skylark-utils-filer.js","sourcesContent":["define('skylark-utils-filer/filer',[\r\n    \"skylark-langx/skylark\"\r\n], function(skylark) {\r\n\r\n    function dataURLtoBlob(dataurl) {\r\n        var arr = dataurl.split(','),\r\n            mime = arr[0].match(/:(.*?);/)[1],\r\n            bstr = atob(arr[1]),\r\n            n = bstr.length,\r\n            u8arr = new Uint8Array(n);\r\n        while (n--) {\r\n            u8arr[n] = bstr.charCodeAt(n);\r\n        }\r\n        return new Blob([u8arr], { type: mime });\r\n    }\r\n\r\n\r\n    var filer = function() {\r\n        return filer;\r\n    };\r\n\r\n    return skylark.filer = filer;\r\n});\ndefine('skylark-utils-filer/download',[\r\n    \"./filer\"\r\n],function(filer){\r\n\r\n    function downloadFile(data, name) {\r\n        if (window.navigator.msSaveBlob) {\r\n            if (types.isString(data)) {\r\n                data = dataURItoBlob(data);\r\n            }\r\n            window.navigator.msSaveBlob(data, name);\r\n        } else {\r\n            var a = document.createElement('a');\r\n            if (data instanceof Blob) {\r\n                data = URL.createObjectURL(data);\r\n            }\r\n            a.href = data;\r\n            a.setAttribute('download', name || 'noname');\r\n            a.dispatchEvent(new CustomEvent('click'));\r\n        }\r\n    }\r\n\r\n    return filer.downlad = downloadFile;\r\n\r\n});\r\n\n define('skylark-utils-filer/webentry',[\r\n    \"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n    \"./filer\"\r\n],function(arrays,Deferred, filer){\r\n    var concat = Array.prototype.concat;\r\n    var webentry = (function() {\r\n        function one(entry, path) {\r\n            var d = new Deferred(),\r\n                onError = function(e) {\r\n                    d.reject(e);\r\n                };\r\n\r\n            path = path || '';\r\n            if (entry.isFile) {\r\n                entry.file(function(file) {\r\n                    file.relativePath = path;\r\n                    d.resolve(file);\r\n                }, onError);\r\n            } else if (entry.isDirectory) {\r\n                var dirReader = entry.createReader();\r\n                dirReader.readEntries(function(entries) {\r\n                    all(\r\n                        entries,\r\n                        path + entry.name + '/'\r\n                    ).then(function(files) {\r\n                        d.resolve(files);\r\n                    }).catch(onError);\r\n                }, onError);\r\n            } else {\r\n                // Return an empy list for file system items\r\n                // other than files or directories:\r\n                d.resolve([]);\r\n            }\r\n            return d.promise;\r\n        }\r\n\r\n        function all(entries, path) {\r\n            return Deferred.all(\r\n                arrays.map(entries, function(entry) {\r\n                    return one(entry, path);\r\n                })\r\n            ).then(function() {\r\n                return concat.apply([], arguments);\r\n            });\r\n        }\r\n\r\n        return {\r\n            one: one,\r\n            all: all\r\n        };\r\n    })();\r\n\r\n    return filer.webentry = webentry;\r\n});\n  define('skylark-utils-filer/dropzone',[\r\n    \"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n    \"skylark-utils-dom/styler\",\r\n    \"skylark-utils-dom/eventer\",\r\n    \"./filer\",\r\n    \"./webentry\"\r\n],function(arrays,Deferred, styler, eventer, filer, webentry){  /*\r\n     * Make the specified element to could accept HTML5 file drag and drop.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} params\r\n     */\r\n    function dropzone(elm, params) {\r\n        params = params || {};\r\n        var hoverClass = params.hoverClass || \"dropzone\",\r\n            droppedCallback = params.dropped;\r\n\r\n        var enterdCount = 0;\r\n        eventer.on(elm, \"dragenter\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                eventer.stop(e);\r\n                enterdCount++;\r\n                styler.addClass(elm, hoverClass)\r\n            }\r\n        });\r\n\r\n        eventer.on(elm, \"dragover\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                eventer.stop(e);\r\n            }\r\n        });\r\n\r\n        eventer.on(elm, \"dragleave\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                enterdCount--\r\n                if (enterdCount == 0) {\r\n                    styler.removeClass(elm, hoverClass);\r\n                }\r\n            }\r\n        });\r\n\r\n        eventer.on(elm, \"drop\", function(e) {\r\n            if (e.dataTransfer && e.dataTransfer.types.indexOf(\"Files\") > -1) {\r\n                styler.removeClass(elm, hoverClass)\r\n                eventer.stop(e);\r\n                if (droppedCallback) {\r\n                    var items = e.dataTransfer.items;\r\n                    if (items && items.length && (items[0].webkitGetAsEntry ||\r\n                            items[0].getAsEntry)) {\r\n                        webentry.all(\r\n                            arrays.map(items, function(item) {\r\n                                if (item.webkitGetAsEntry) {\r\n                                    return item.webkitGetAsEntry();\r\n                                }\r\n                                return item.getAsEntry();\r\n                            })\r\n                        ).then(droppedCallback);\r\n                    } else {\r\n                        droppedCallback(e.dataTransfer.files);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n     return filer.dropzone = dropzone;\r\n});\ndefine('skylark-utils-filer/pastezone',[\r\n    \"skylark-langx/objects\",\r\n    \"skylark-utils-dom/eventer\",\r\n    \"./filer\"\r\n],function(objects, eventer, filer){\r\n    function pastezone(elm, params) {\r\n        params = params || {};\r\n        var hoverClass = params.hoverClass || \"pastezone\",\r\n            pastedCallback = params.pasted;\r\n\r\n        eventer.on(elm, \"paste\", function(e) {\r\n            var items = e.originalEvent && e.originalEvent.clipboardData &&\r\n                e.originalEvent.clipboardData.items,\r\n                files = [];\r\n            if (items && items.length) {\r\n                objects.each(items, function(index, item) {\r\n                    var file = item.getAsFile && item.getAsFile();\r\n                    if (file) {\r\n                        files.push(file);\r\n                    }\r\n                });\r\n            }\r\n            if (pastedCallback && files.length) {\r\n                pastedCallback(files);\r\n            }\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    return filer.pastezone = pastezone;\r\n\r\n});\r\n\ndefine('skylark-utils-filer/select',[\r\n    \"./filer\"\r\n],function(filer){\r\n    var fileInput,\r\n        fileInputForm,\r\n        fileSelected,\r\n        maxFileSize = 1 / 0;\r\n\r\n    function select(params) {\r\n        params = params || {};\r\n        var directory = params.directory || false,\r\n            multiple = params.multiple || false,\r\n            fileSelected = params.picked;\r\n        if (!fileInput) {\r\n            var input = fileInput = document.createElement(\"input\");\r\n\r\n            function selectFiles(pickedFiles) {\r\n                for (var i = pickedFiles.length; i--;) {\r\n                    if (pickedFiles[i].size > maxFileSize) {\r\n                        pickedFiles.splice(i, 1);\r\n                    }\r\n                }\r\n                fileSelected(pickedFiles);\r\n            }\r\n\r\n            input.type = \"file\";\r\n            input.style.position = \"fixed\";\r\n            input.style.left = 0;\r\n            input.style.top = 0;\r\n            input.style.opacity = .001;\r\n            document.body.appendChild(input);\r\n\r\n            input.onchange = function(e) {\r\n                var entries = e.target.webkitEntries || e.target.entries;\r\n\r\n                if (entries && entries.length) {\r\n                    webentry.all(entries).then(function(files) {\r\n                        selectFiles(files);\r\n                    });\r\n                } else {\r\n                    selectFiles(Array.prototype.slice.call(e.target.files));\r\n                }\r\n                // reset to \"\", so selecting the same file next time still trigger the change handler\r\n                input.value = \"\";\r\n            };\r\n        }\r\n        fileInput.multiple = multiple;\r\n        fileInput.webkitdirectory = directory;\r\n        fileInput.click();\r\n    }\r\n\r\n    return filer.select = select;\r\n});\r\n\r\n\ndefine('skylark-utils-filer/picker',[\r\n    \"skylark-langx/objects\",\r\n    \"skylark-utils-dom/eventer\",\r\n    \"./filer\",\r\n    \"./select\",\r\n],function(objects, eventer, filer, select){\r\n    /*\r\n     * Make the specified element to pop-up the file selection dialog box when clicked , and read the contents the files selected from client file system by user.\r\n     * @param {HTMLElement} elm\r\n     * @param {PlainObject} params\r\n     */\r\n    function picker(elm, params) {\r\n        eventer.on(elm, \"click\", function(e) {\r\n            e.preventDefault();\r\n            select(params);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    return filer.picker = picker;\r\n\r\n});\r\n\r\n\r\n\ndefine('skylark-utils-filer/read',[\r\n    \"skylark-langx/Deferred\",\r\n    \"./filer\"\r\n],function(Deferred, filer){\r\n\r\n    function readFile(file, params) {\r\n        params = params || {};\r\n        var d = new Deferred,\r\n            reader = new FileReader();\r\n\r\n        reader.onload = function(evt) {\r\n            d.resolve(evt.target.result);\r\n        };\r\n        reader.onerror = function(e) {\r\n            var code = e.target.error.code;\r\n            if (code === 2) {\r\n                alert('please don\\'t open this page using protocol fill:///');\r\n            } else {\r\n                alert('error code: ' + code);\r\n            }\r\n        };\r\n\r\n        if (params.asArrayBuffer) {\r\n            reader.readAsArrayBuffer(file);\r\n        } else if (params.asDataUrl) {\r\n            reader.readAsDataURL(file);\r\n        } else if (params.asText) {\r\n            reader.readAsText(file);\r\n        } else {\r\n            reader.readAsArrayBuffer(file);\r\n        }\r\n\r\n        return d.promise;\r\n    }\r\n\r\n    return filer.read = filer.readFile = readFile;\r\n    \r\n});\r\n\ndefine('skylark-utils-filer/upload',[\r\n\t\"skylark-langx/types\",\r\n\t\"skylark-langx/objects\",\r\n\t\"skylark-langx/arrays\",\r\n    \"skylark-langx/Deferred\",\r\n\t\"skylark-langx/Xhr\",\r\n\t\"./filer\"\r\n],function(types, objects, arrays, Deferred,Xhr, filer){\r\n\r\n    function upload(params) {\r\n        var xoptions = objects.mixin({\r\n            contentRange: null, //\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: true,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function(message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    objects.each(context, function(key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function(form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function(e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false &&\r\n                        $(this).fileupload('option', 'autoUpload'))) {\r\n                    data.process().done(function() {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        }, params);\r\n\r\n        var blobSlice = function() {\r\n                var slice = Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice;\r\n  \t            return slice.apply(this, arguments);\r\n            },\r\n            ajax = function(data) {\r\n                return Xhr.request(data.url, data);\r\n            };\r\n\r\n        function initDataSettings(o) {\r\n            o.type = o.type || \"POST\";\r\n\r\n            if (!chunkedUpload(o, true)) {\r\n                if (!o.data) {\r\n                    initXHRData(o);\r\n                }\r\n                //initProgressListener(o);\r\n            }\r\n        }\r\n\r\n        function initXHRData(o) {\r\n            var that = this,\r\n                formData,\r\n                file = o.files[0],\r\n                // Ignore non-multipart setting if not supported:\r\n                multipart = o.multipart,\r\n                paramName = types.type(o.paramName) === 'array' ?\r\n                o.paramName[0] : o.paramName;\r\n\r\n            o.headers = objects.mixin({}, o.headers);\r\n            if (o.contentRange) {\r\n                o.headers['Content-Range'] = o.contentRange;\r\n            }\r\n            if (!multipart) {\r\n                o.headers['Content-Disposition'] = 'attachment; filename=\"' +\r\n                    encodeURI(file.name) + '\"';\r\n                o.contentType = file.type || 'application/octet-stream';\r\n                o.data = o.blob || file;\r\n            } else {\r\n                formData = new FormData();\r\n                if (o.blob) {\r\n                    formData.append(paramName, o.blob, file.name);\r\n                } else {\r\n                    objects.each(o.files, function(index, file) {\r\n                        // This check allows the tests to run with\r\n                        // dummy objects:\r\n                        formData.append(\r\n                            (types.type(o.paramName) === 'array' &&\r\n                                o.paramName[index]) || paramName,\r\n                            file,\r\n                            file.uploadName || file.name\r\n                        );\r\n                    });\r\n                }\r\n                o.data = formData;\r\n            }\r\n            // Blob reference is not needed anymore, free memory:\r\n            o.blob = null;\r\n        }\r\n\r\n        function getTotal(files) {\r\n            var total = 0;\r\n            objects.each(files, function(index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        }\r\n\r\n        function getUploadedBytes(jqXHR) {\r\n            var range = jqXHR.getResponseHeader('Range'),\r\n                parts = range && range.split('-'),\r\n                upperBytesPos = parts && parts.length > 1 &&\r\n                parseInt(parts[1], 10);\r\n            return upperBytesPos && upperBytesPos + 1;\r\n        }\r\n\r\n        function initProgressObject(obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                objects.mixin(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        }\r\n\r\n        function BitrateTimer() {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function(now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        }\r\n\r\n        function chunkedUpload(options, testOnly) {\r\n            options.uploadedBytes = options.uploadedBytes || 0;\r\n            var that = this,\r\n                file = options.files[0],\r\n                fs = file.size,\r\n                ub = options.uploadedBytes,\r\n                mcs = options.maxChunkSize || fs,\r\n                slice = blobSlice,\r\n                dfd = new Deferred(),\r\n                promise = dfd.promise,\r\n                jqXHR,\r\n                upload;\r\n            if (!(slice && (ub || mcs < fs)) ||\r\n                options.data) {\r\n                return false;\r\n            }\r\n            if (testOnly) {\r\n                return true;\r\n            }\r\n            if (ub >= fs) {\r\n                file.error = options.i18n('uploadedBytes');\r\n                return this._getXHRPromise(\r\n                    false,\r\n                    options.context, [null, 'error', file.error]\r\n                );\r\n            }\r\n            // The chunk upload method:\r\n            upload = function() {\r\n                // Clone the options object for each chunk upload:\r\n                var o = objects.mixin({}, options),\r\n                    currentLoaded = o._progress.loaded;\r\n                o.blob = slice.call(\r\n                    file,\r\n                    ub,\r\n                    ub + mcs,\r\n                    file.type\r\n                );\r\n                // Store the current chunk size, as the blob itself\r\n                // will be dereferenced after data processing:\r\n                o.chunkSize = o.blob.size;\r\n                // Expose the chunk bytes position range:\r\n                o.contentRange = 'bytes ' + ub + '-' +\r\n                    (ub + o.chunkSize - 1) + '/' + fs;\r\n                // Process the upload data (the blob and potential form data):\r\n                initXHRData(o);\r\n                // Add progress listeners for this chunk upload:\r\n                //initProgressListener(o);\r\n                jqXHR = ajax(o).done(function(result, textStatus, jqXHR) {\r\n                        ub = getUploadedBytes(jqXHR) ||\r\n                            (ub + o.chunkSize);\r\n                        // Create a progress event if no final progress event\r\n                        // with loaded equaling total has been triggered\r\n                        // for this chunk:\r\n                        if (currentLoaded + o.chunkSize - o._progress.loaded) {\r\n                            dfd.progress({\r\n                                lengthComputable: true,\r\n                                loaded: ub - o.uploadedBytes,\r\n                                total: ub - o.uploadedBytes\r\n                            });\r\n                        }\r\n                        options.uploadedBytes = o.uploadedBytes = ub;\r\n                        o.result = result;\r\n                        o.textStatus = textStatus;\r\n                        o.jqXHR = jqXHR;\r\n                        //that._trigger('chunkdone', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        if (ub < fs) {\r\n                            // File upload not yet complete,\r\n                            // continue with the next chunk:\r\n                            upload();\r\n                        } else {\r\n                            dfd.resolveWith(\r\n                                o.context, [result, textStatus, jqXHR]\r\n                            );\r\n                        }\r\n                    })\r\n                    .fail(function(jqXHR, textStatus, errorThrown) {\r\n                        o.jqXHR = jqXHR;\r\n                        o.textStatus = textStatus;\r\n                        o.errorThrown = errorThrown;\r\n                        //that._trigger('chunkfail', null, o);\r\n                        //that._trigger('chunkalways', null, o);\r\n                        dfd.rejectWith(\r\n                            o.context, [jqXHR, textStatus, errorThrown]\r\n                        );\r\n                    });\r\n            };\r\n            //this._enhancePromise(promise);\r\n            promise.abort = function() {\r\n                return jqXHR.abort();\r\n            };\r\n            upload();\r\n            return promise;\r\n        }\r\n\r\n        initDataSettings(xoptions);\r\n\r\n        xoptions._bitrateTimer = new BitrateTimer();\r\n\r\n        var jqXhr = chunkedUpload(xoptions) || ajax(xoptions);\r\n\r\n        jqXhr.options = xoptions;\r\n\r\n        return jqXhr;\r\n    }\r\n\r\n\treturn filer.upload = upload;\t\r\n});\ndefine('skylark-utils-filer/uploader',[\r\n    \"skylark-langx/langx\",\r\n    \"skylark-utils-dom/eventer\",\r\n    \"skylark-utils-dom/query\",\r\n    \"./filer\",\r\n    \"./dropzone\",\r\n    \"./pastezone\",\r\n    \"./picker\",\r\n    \"./upload\"\r\n],function (langx,eventer,$,filer,dropzone,pastezone,picker,upload) {\r\n    'use strict';\r\n\r\n    var Deferred = langx.Deferred;\r\n\r\n\r\n    // The fileupload widget listens for change events on file input fields defined\r\n    // via fileInput setting and paste or drop events of the given dropZone.\r\n    // In addition to the default jQuery Widget methods, the fileupload widget\r\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\r\n    // the fileupload API.\r\n    // By default, files added via file input selection, paste, drag & drop or\r\n    // \"add\" method are uploaded immediately, but it is possible to override\r\n    // the \"add\" callback option to queue file uploads.\r\n\r\n    var FileUploader = langx.Evented.inherit( {\r\n\r\n        options: {\r\n            // The drop target element(s), by the default the complete document.\r\n            // Set to null to disable drag & drop support:\r\n            dropZone: $(document),\r\n\r\n            // The paste target element(s), by the default the complete document.\r\n            // Set to null to disable paste support:\r\n            pasteZone: $(document),\r\n\r\n            // The file input field(s), that are listened to for change events.\r\n            // If undefined, it is set to the file input fields inside\r\n            // of the widget element on plugin initialization.\r\n            // Set to null to disable the change listener.\r\n            picker: undefined,\r\n\r\n\r\n            // The parameter name for the file form data (the request argument name).\r\n            // If undefined or empty, the name property of the file input field is\r\n            // used, or \"files[]\" if the file input name property is also empty,\r\n            // can be a string or an array of strings:\r\n            paramName: undefined,\r\n            \r\n            // By default, each file of a selection is uploaded using an individual\r\n            // request for XHR type uploads. Set to false to upload file\r\n            // selections in one request each:\r\n            singleFileUploads: true,\r\n            \r\n            // To limit the number of files uploaded with one XHR request,\r\n            // set the following option to an integer greater than 0:\r\n            limitMultiFileUploads: undefined,\r\n            \r\n            // The following option limits the number of files uploaded with one\r\n            // XHR request to keep the request size under or equal to the defined\r\n            // limit in bytes:\r\n            limitMultiFileUploadSize: undefined,\r\n\r\n            // Multipart file uploads add a number of bytes to each uploaded file,\r\n            // therefore the following option adds an overhead for each file used\r\n            // in the limitMultiFileUploadSize configuration:\r\n            limitMultiFileUploadSizeOverhead: 512,\r\n\r\n            // Set the following option to true to issue all file upload requests\r\n            // in a sequential order:\r\n            sequentialUploads: false,\r\n            \r\n            // To limit the number of concurrent uploads,\r\n            // set the following option to an integer greater than 0:\r\n            limitConcurrentUploads: undefined,\r\n\r\n            // Set the following option to the location of a postMessage window,\r\n            // to enable postMessage transport uploads:\r\n            postMessage: undefined,\r\n \r\n            // By default, XHR file uploads are sent as multipart/form-data.\r\n            // The iframe transport is always using multipart/form-data.\r\n            // Set to false to enable non-multipart XHR uploads:\r\n            multipart: true,\r\n \r\n            // To upload large files in smaller chunks, set the following option\r\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\r\n            // or the browser does not support the required Blob API, files will\r\n            // be uploaded as a whole.\r\n            maxChunkSize: undefined,\r\n \r\n            // When a non-multipart upload or a chunked multipart upload has been\r\n            // aborted, this option can be used to resume the upload by setting\r\n            // it to the size of the already uploaded bytes. This option is most\r\n            // useful when modifying the options object inside of the \"add\" or\r\n            // \"send\" callbacks, as the options are cloned for each file upload.\r\n            uploadedBytes: undefined,\r\n \r\n            // By default, failed (abort or error) file uploads are removed from the\r\n            // global progress calculation. Set the following option to false to\r\n            // prevent recalculating the global progress data:\r\n            recalculateProgress: true,\r\n \r\n            // Interval in milliseconds to calculate and trigger progress events:\r\n            progressInterval: 100,\r\n \r\n            // Interval in milliseconds to calculate progress bitrate:\r\n            bitrateInterval: 500,\r\n \r\n            // By default, uploads are started automatically when adding files:\r\n            autoUpload: false,\r\n\r\n            // Error and info messages:\r\n            messages: {\r\n                uploadedBytes: 'Uploaded bytes exceed file size'\r\n            },\r\n\r\n            // Translation function, gets the message key to be translated\r\n            // and an object with context specific data as arguments:\r\n            i18n: function (message, context) {\r\n                message = this.messages[message] || message.toString();\r\n                if (context) {\r\n                    langx.each(context, function (key, value) {\r\n                        message = message.replace('{' + key + '}', value);\r\n                    });\r\n                }\r\n                return message;\r\n            },\r\n\r\n            // Additional form data to be sent along with the file uploads can be set\r\n            // using this option, which accepts an array of objects with name and\r\n            // value properties, a function returning such an array, a FormData\r\n            // object (for XHR file uploads), or a simple object.\r\n            // The form of the first fileInput is given as parameter to the function:\r\n            formData: function (form) {\r\n                return form.serializeArray();\r\n            },\r\n\r\n            // The add callback is invoked as soon as files are added to the fileupload\r\n            // widget (via file input selection, drag & drop, paste or add API call).\r\n            // If the singleFileUploads option is enabled, this callback will be\r\n            // called once for each file in the selection for XHR file uploads, else\r\n            // once for each file selection.\r\n            //\r\n            // The upload starts when the submit method is invoked on the data parameter.\r\n            // The data object contains a files property holding the added files\r\n            // and allows you to override plugin options as well as define ajax settings.\r\n            //\r\n            // Listeners for this callback can also be bound the following way:\r\n            // .bind('fileuploadadd', func);\r\n            //\r\n            // data.submit() returns a Promise object and allows to attach additional\r\n            // handlers using jQuery's Deferred callbacks:\r\n            // data.submit().done(func).fail(func).always(func);\r\n            add: function (e, data) {\r\n                if (e.isDefaultPrevented()) {\r\n                    return false;\r\n                }\r\n                if (data.autoUpload || (data.autoUpload !== false && $(this).fileupload(\"instance\").option('autoUpload') )) {\r\n                    data.process().done(function () {\r\n                        data.submit();\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Other callbacks:\r\n\r\n            // Callback for the submit event of each file upload:\r\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\r\n\r\n            // Callback for the start of each file upload request:\r\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\r\n\r\n            // Callback for successful uploads:\r\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\r\n\r\n            // Callback for failed (abort or error) uploads:\r\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\r\n\r\n            // Callback for completed (success, abort or error) requests:\r\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\r\n\r\n            // Callback for upload progress events:\r\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\r\n\r\n            // Callback for global upload progress events:\r\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\r\n\r\n            // Callback for uploads start, equivalent to the global ajaxStart event:\r\n            // start: function (e) {}, // .bind('fileuploadstart', func);\r\n\r\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\r\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\r\n\r\n            // Callback for change events of the fileInput(s):\r\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\r\n\r\n            // Callback for paste events to the pasteZone(s):\r\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\r\n\r\n            // Callback for drop events of the dropZone(s):\r\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\r\n\r\n            // Callback for dragover events of the dropZone(s):\r\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\r\n\r\n            // Callback for the start of each chunk upload request:\r\n            // chunksend: function (e, data) {}, // .bind('fileuploadchunksend', func);\r\n\r\n            // Callback for successful chunk uploads:\r\n            // chunkdone: function (e, data) {}, // .bind('fileuploadchunkdone', func);\r\n\r\n            // Callback for failed (abort or error) chunk uploads:\r\n            // chunkfail: function (e, data) {}, // .bind('fileuploadchunkfail', func);\r\n\r\n            // Callback for completed (success, abort or error) chunk upload requests:\r\n            // chunkalways: function (e, data) {}, // .bind('fileuploadchunkalways', func);\r\n\r\n            // The plugin options are used as settings object for the ajax calls.\r\n            // The following are jQuery ajax settings required for the file uploads:\r\n            processData: false,\r\n            contentType: false,\r\n            cache: false\r\n        },\r\n\r\n        // A list of options that require reinitializing event listeners and/or\r\n        // special initialization code:\r\n        _specialOptions: [\r\n            'picker',\r\n            'dropZone',\r\n            'pasteZone',\r\n            'multipart',\r\n            'filesContainer',\r\n            'uploadTemplateId',\r\n            'downloadTemplateId'            \r\n        ],\r\n\r\n        _BitrateTimer: function () {\r\n            this.timestamp = ((Date.now) ? Date.now() : (new Date()).getTime());\r\n            this.loaded = 0;\r\n            this.bitrate = 0;\r\n            this.getBitrate = function (now, loaded, interval) {\r\n                var timeDiff = now - this.timestamp;\r\n                if (!this.bitrate || !interval || timeDiff > interval) {\r\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\r\n                    this.loaded = loaded;\r\n                    this.timestamp = now;\r\n                }\r\n                return this.bitrate;\r\n            };\r\n        },\r\n\r\n        _getTotal: function (files) {\r\n            var total = 0;\r\n            langx.each(files, function (index, file) {\r\n                total += file.size || 1;\r\n            });\r\n            return total;\r\n        },\r\n\r\n        _initProgressObject: function (obj) {\r\n            var progress = {\r\n                loaded: 0,\r\n                total: 0,\r\n                bitrate: 0\r\n            };\r\n            if (obj._progress) {\r\n                langx.extend(obj._progress, progress);\r\n            } else {\r\n                obj._progress = progress;\r\n            }\r\n        },\r\n\r\n        _initResponseObject: function (obj) {\r\n            var prop;\r\n            if (obj._response) {\r\n                for (prop in obj._response) {\r\n                    if (obj._response.hasOwnProperty(prop)) {\r\n                        delete obj._response[prop];\r\n                    }\r\n                }\r\n            } else {\r\n                obj._response = {};\r\n            }\r\n        },\r\n\r\n        _onProgress: function (e, data) {\r\n            if (e.lengthComputable) {\r\n                var now = ((Date.now) ? Date.now() : (new Date()).getTime()),\r\n                    loaded;\r\n                if (data._time && data.progressInterval &&\r\n                        (now - data._time < data.progressInterval) &&\r\n                        e.loaded !== e.total) {\r\n                    return;\r\n                }\r\n                data._time = now;\r\n                loaded = Math.floor(\r\n                    e.loaded / e.total * (data.chunkSize || data._progress.total)\r\n                ) + (data.uploadedBytes || 0);\r\n                // Add the difference from the previously loaded state\r\n                // to the global loaded counter:\r\n                this._progress.loaded += (loaded - data._progress.loaded);\r\n                this._progress.bitrate = this._bitrateTimer.getBitrate(\r\n                    now,\r\n                    this._progress.loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                data._progress.loaded = data.loaded = loaded;\r\n                data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(\r\n                    now,\r\n                    loaded,\r\n                    data.bitrateInterval\r\n                );\r\n                // Trigger a custom progress event with a total data property set\r\n                // to the file size(s) of the current upload and a loaded data\r\n                // property calculated accordingly:\r\n                this._trigger(\r\n                    'progress',\r\n                    eventer.create('progress', {delegatedEvent: e}),\r\n                    data\r\n                );\r\n                // Trigger a global progress event for all current file uploads,\r\n                // including ajax calls queued for sequential file uploads:\r\n                this._trigger(\r\n                    'progressall',\r\n                    eventer.create('progressall', {delegatedEvent: e}),\r\n                    this._progress\r\n                );\r\n            }\r\n        },\r\n\r\n        _getParamName: function (options) {\r\n            var picker = $(options.picker),\r\n                paramName = options.paramName;\r\n            //if (!paramName) {\r\n            //    paramName = [fileInput.prop('name') || 'files[]'];\r\n            // } else if (!langx.isArray(paramName)) {\r\n\r\n            if (!langx.isArray(paramName)) {\r\n                paramName = [paramName];\r\n            }\r\n            return paramName;\r\n        },\r\n\r\n\r\n        // jQuery 1.6 doesn't provide .state(),\r\n        // while jQuery 1.8+ removed .isRejected() and .isResolved():\r\n        _getDeferredState: function (deferred) {\r\n            if (deferred.state) {\r\n                return deferred.state();\r\n            }\r\n            if (deferred.isResolved()) {\r\n                return 'resolved';\r\n            }\r\n            if (deferred.isRejected()) {\r\n                return 'rejected';\r\n            }\r\n            return 'pending';\r\n        },\r\n\r\n        // Maps jqXHR callbacks to the equivalent\r\n        // methods of the given Promise object:\r\n        _enhancePromise: function (promise) {\r\n            promise.success = promise.done;\r\n            promise.error = promise.fail;\r\n            promise.complete = promise.always;\r\n            return promise;\r\n        },\r\n\r\n        // Creates and returns a Promise object enhanced with\r\n        // the jqXHR methods abort, success, error and complete:\r\n        _getXHRPromise: function (resolveOrReject, context, args) {\r\n            var dfd = new Deferred(),\r\n                promise = dfd.promise;\r\n            context = context || this.options.context || promise;\r\n            if (resolveOrReject === true) {\r\n                dfd.resolveWith(context, args);\r\n            } else if (resolveOrReject === false) {\r\n                dfd.rejectWith(context, args);\r\n            }\r\n            promise.abort = dfd.promise;\r\n            return this._enhancePromise(promise);\r\n        },\r\n\r\n        // Adds convenience methods to the data callback argument:\r\n        _addConvenienceMethods: function (e, data) {\r\n            var that = this,\r\n                getPromise = function (args) {\r\n                    return new Deferred().resolveWith(that, args).promise;\r\n                };\r\n            data.process = function (resolveFunc, rejectFunc) {\r\n                if (resolveFunc || rejectFunc) {\r\n                    data._processQueue = this._processQueue =\r\n                        (this._processQueue || getPromise([this])).pipe(\r\n                            function () {\r\n                                if (data.errorThrown) {\r\n                                    return new Deferred()\r\n                                        .rejectWith(that, [data]).promise;\r\n                                }\r\n                                return getPromise(arguments);\r\n                            }\r\n                        ).pipe(resolveFunc, rejectFunc);\r\n                }\r\n                return this._processQueue || getPromise([this]);\r\n            };\r\n            data.submit = function () {\r\n                if (this.state() !== 'pending') {\r\n                    data.jqXHR = this.jqXHR =\r\n                        (that._trigger(\r\n                            'submit',\r\n                            eventer.create('submit', {delegatedEvent: e}),\r\n                            this\r\n                        ) !== false) && that._onSend(e, this);\r\n                }\r\n                return this.jqXHR || that._getXHRPromise();\r\n            };\r\n            data.abort = function () {\r\n                if (this.jqXHR) {\r\n                    return this.jqXHR.abort();\r\n                }\r\n                this.errorThrown = 'abort';\r\n                that._trigger('fail', null, this);\r\n                return that._getXHRPromise(false);\r\n            };\r\n            data.state = function () {\r\n                if (this.jqXHR) {\r\n                    return that._getDeferredState(this.jqXHR);\r\n                }\r\n                if (this._processQueue) {\r\n                    return that._getDeferredState(this._processQueue);\r\n                }\r\n            };\r\n            data.processing = function () {\r\n                return !this.jqXHR && this._processQueue && that\r\n                    ._getDeferredState(this._processQueue) === 'pending';\r\n            };\r\n            data.progress = function () {\r\n                return this._progress;\r\n            };\r\n            data.response = function () {\r\n                return this._response;\r\n            };\r\n        },\r\n\r\n        _beforeSend: function (e, data) {\r\n            if (this._active === 0) {\r\n                // the start callback is triggered when an upload starts\r\n                // and no other uploads are currently running,\r\n                // equivalent to the global ajaxStart event:\r\n                this._trigger('start');\r\n                // Set timer for global bitrate progress calculation:\r\n                this._bitrateTimer = new this._BitrateTimer();\r\n                // Reset the global progress values:\r\n                this._progress.loaded = this._progress.total = 0;\r\n                this._progress.bitrate = 0;\r\n            }\r\n            // Make sure the container objects for the .response() and\r\n            // .progress() methods on the data object are available\r\n            // and reset to their initial state:\r\n            this._initResponseObject(data);\r\n            this._initProgressObject(data);\r\n            data._progress.loaded = data.loaded = data.uploadedBytes || 0;\r\n            data._progress.total = data.total = this._getTotal(data.files) || 1;\r\n            data._progress.bitrate = data.bitrate = 0;\r\n            this._active += 1;\r\n            // Initialize the global progress values:\r\n            this._progress.loaded += data.loaded;\r\n            this._progress.total += data.total;\r\n        },\r\n\r\n        _onDone: function (result, textStatus, jqXHR, options) {\r\n            var total = options._progress.total,\r\n                response = options._response;\r\n            if (options._progress.loaded < total) {\r\n                // Create a progress event if no final progress event\r\n                // with loaded equaling total has been triggered:\r\n                this._onProgress(eventer.create('progress', {\r\n                    lengthComputable: true,\r\n                    loaded: total,\r\n                    total: total\r\n                }), options);\r\n            }\r\n            response.result = options.result = result;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            this._trigger('done', null, options);\r\n        },\r\n\r\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\r\n            var response = options._response;\r\n            if (options.recalculateProgress) {\r\n                // Remove the failed (error or abort) file upload from\r\n                // the global progress calculation:\r\n                this._progress.loaded -= options._progress.loaded;\r\n                this._progress.total -= options._progress.total;\r\n            }\r\n            response.jqXHR = options.jqXHR = jqXHR;\r\n            response.textStatus = options.textStatus = textStatus;\r\n            response.errorThrown = options.errorThrown = errorThrown;\r\n            this._trigger('fail', null, options);\r\n        },\r\n\r\n        _trigger : function(type,event,data) {\r\n            var e = eventer.proxy(event);\r\n            e.type = type;\r\n            e.data =data;\r\n            return this.trigger(e,data);\r\n        },\r\n\r\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\r\n            // jqXHRorResult, textStatus and jqXHRorError are added to the\r\n            // options object via done and fail callbacks\r\n            this._trigger('always', null, options);\r\n        },\r\n\r\n        _onSend: function (e, data) {\r\n            if (!data.submit) {\r\n                this._addConvenienceMethods(e, data);\r\n            }\r\n            var that = this,\r\n                jqXHR,\r\n                aborted,\r\n                slot,\r\n                pipe,\r\n                send = function () {\r\n                    that._sending += 1;\r\n                    data.url = that.options.url;\r\n                    data.dataType = that.options.dataType;\r\n                    data.xhrFields = that.options.xhrFields;\r\n\r\n                    jqXHR = upload(data);\r\n\r\n                    jqXHR.progress(function(e){\r\n                        //var oe = e.originalEvent;\r\n                        // Make sure the progress event properties get copied over:\r\n                        //e.lengthComputable = oe.lengthComputable;\r\n                        //e.loaded = oe.loaded;\r\n                        //e.total = oe.total;\r\n                        that._onProgress(e, jqXHR.options);\r\n\r\n                    }).done(function (result, textStatus) {\r\n                        that._onDone(result, textStatus, jqXHR, jqXHR.options);\r\n                    }).fail(function (e, textStatus) {\r\n                        that._onFail(jqXHR, textStatus,e, jqXHR.options);\r\n                    }).always(function () {\r\n                        that._sending -= 1;\r\n                        that._active -= 1;\r\n                        that._trigger('stop');\r\n                    });\r\n                    return jqXHR;\r\n                };\r\n            this._beforeSend(e, data);\r\n\r\n            return send();\r\n        },\r\n        _onAdd: function (e, data) {\r\n            var that = this,\r\n                result = true,\r\n                options = langx.extend({}, this.options, data),\r\n                files = data.files,\r\n                filesLength = files.length,\r\n                limit = options.limitMultiFileUploads,\r\n                limitSize = options.limitMultiFileUploadSize,\r\n                overhead = options.limitMultiFileUploadSizeOverhead,\r\n                batchSize = 0,\r\n                paramName = this._getParamName(options),\r\n                paramNameSet,\r\n                paramNameSlice,\r\n                fileSet,\r\n                i,\r\n                j = 0;\r\n            if (limitSize && (!filesLength || files[0].size === undefined)) {\r\n                limitSize = undefined;\r\n            }\r\n            if (!(options.singleFileUploads || limit || limitSize)) {\r\n                fileSet = [files];\r\n                paramNameSet = [paramName];\r\n            } else if (!(options.singleFileUploads || limitSize) && limit) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i += limit) {\r\n                    fileSet.push(files.slice(i, i + limit));\r\n                    paramNameSlice = paramName.slice(i, i + limit);\r\n                    if (!paramNameSlice.length) {\r\n                        paramNameSlice = paramName;\r\n                    }\r\n                    paramNameSet.push(paramNameSlice);\r\n                }\r\n            } else if (!options.singleFileUploads && limitSize) {\r\n                fileSet = [];\r\n                paramNameSet = [];\r\n                for (i = 0; i < filesLength; i = i + 1) {\r\n                    batchSize += files[i].size + overhead;\r\n                    if (i + 1 === filesLength ||\r\n                            ((batchSize + files[i + 1].size + overhead) > limitSize) ||\r\n                            (limit && i + 1 - j >= limit)) {\r\n                        fileSet.push(files.slice(j, i + 1));\r\n                        paramNameSlice = paramName.slice(j, i + 1);\r\n                        if (!paramNameSlice.length) {\r\n                            paramNameSlice = paramName;\r\n                        }\r\n                        paramNameSet.push(paramNameSlice);\r\n                        j = i + 1;\r\n                        batchSize = 0;\r\n                    }\r\n                }\r\n            } else {\r\n                paramNameSet = paramName;\r\n            }\r\n            data.originalFiles = files;\r\n            langx.each(fileSet || files, function (index, element) {\r\n                var newData = langx.extend({}, data);\r\n                newData.files = fileSet ? element : [element];\r\n                newData.paramName = paramNameSet[index];\r\n                that._initResponseObject(newData);\r\n                that._initProgressObject(newData);\r\n                that._addConvenienceMethods(e, newData);\r\n                result = that._trigger(\r\n                    'add',\r\n                    eventer.create('add', {delegatedEvent: e}),\r\n                    newData\r\n                );\r\n                return result;\r\n            });\r\n            return result;\r\n        },\r\n\r\n        _initEventHandlers: function () {\r\n            var that = this;\r\n\r\n            dropzone(this.options.dropZone[0],{\r\n                dropped : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n\r\n            pastezone(this.options.pasteZone[0],{\r\n                pasted : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n\r\n            picker(this.options.picker[0],{\r\n                multiple: true,\r\n                picked : function (files) {\r\n                    var data = {};\r\n                    data.files = files;\r\n                    that._onAdd(null, data);\r\n                }\r\n            });\r\n        },\r\n\r\n        _destroyEventHandlers: function () {\r\n            //this._off(this.options.dropZone, 'dragover drop');\r\n            //this._off(this.options.pasteZone, 'paste');\r\n            //this._off(this.options.picker, 'change');\r\n        },\r\n\r\n        _setOption: function (key, value) {\r\n            var reinit = langx.inArray(key, this._specialOptions) !== -1;\r\n            if (reinit) {\r\n                this._destroyEventHandlers();\r\n            }\r\n            this._super(key, value);\r\n            if (reinit) {\r\n                this._initSpecialOptions();\r\n                this._initEventHandlers();\r\n            }\r\n        },\r\n\r\n        _initSpecialOptions: function () {\r\n            var options = this.options;\r\n            //if (options.fileInput === undefined) {\r\n            //    //options.fileInput = this.element.is('input[type=\"file\"]') ?\r\n            //    //        this.element : this.element.find('input[type=\"file\"]');\r\n            //    options.fileInput = this.element.find('.fileinput-button');\r\n            \r\n            if (options.picker) {\r\n                if (!(options.picker instanceof $)) {\r\n                    options.picker = $(options.picker,this._elm);\r\n                }                \r\n            }\r\n\r\n            if (options.dropZone) {\r\n                if (!(options.dropZone instanceof $)) {\r\n                    options.dropZone = $(options.dropZone,this._elm);\r\n                }\r\n            }\r\n\r\n            if (options.pasteZone) {\r\n                if (!(options.pasteZone instanceof $)) {\r\n                    options.pasteZone = $(options.pasteZone,this._elm);\r\n                }                \r\n            }\r\n        },\r\n\r\n        _getRegExp: function (str) {\r\n            var parts = str.split('/'),\r\n                modifiers = parts.pop();\r\n            parts.shift();\r\n            return new RegExp(parts.join('/'), modifiers);\r\n        },\r\n\r\n        _isRegExpOption: function (key, value) {\r\n            return key !== 'url' && langx.type(value) === 'string' &&\r\n                /^\\/.*\\/[igm]{0,3}$/.test(value);\r\n        },\r\n\r\n        _construct: function (elm,options) {\r\n            this._elm = elm;\r\n            this.options = langx.mixin({},this.options,options);\r\n            this._initSpecialOptions();\r\n            this._slots = [];\r\n            this._sequence = this._getXHRPromise(true);\r\n            this._sending = this._active = 0;\r\n            this._initProgressObject(this);\r\n            this._initEventHandlers();\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the number of active uploads:\r\n        active: function () {\r\n            return this._active;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows to query\r\n        // the widget upload progress.\r\n        // It returns an object with loaded, total and bitrate properties\r\n        // for the running uploads:\r\n        progress: function () {\r\n            return this._progress;\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows adding files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files property and can contain additional options:\r\n        // .fileupload('add', {files: filesList});\r\n        add: function (data) {\r\n            var that = this;\r\n            if (!data || this.options.disabled) {\r\n                return;\r\n            }\r\n            data.files = langx.makeArray(data.files);\r\n            this._onAdd(null, data);\r\n        },\r\n\r\n        // This method is exposed to the widget API and allows sending files\r\n        // using the fileupload API. The data parameter accepts an object which\r\n        // must have a files or fileInput property and can contain additional options:\r\n        // .fileupload('send', {files: filesList});\r\n        // The method returns a Promise object for the file upload call.\r\n        send: function (data) {\r\n            if (data && !this.options.disabled) {\r\n                data.files = langx.makeArray(data.files);\r\n                if (data.files.length) {\r\n                    return this._onSend(null, data);\r\n                }\r\n            }\r\n            return this._getXHRPromise(false, data && data.context);\r\n        }\r\n\r\n    });\r\n\r\n\r\n    function uploader(elm,options) {\r\n        var fuInst = new FileUploader(elm,options);\r\n        fuInst.on(\"all\",function(evt,data){\r\n            var typ = evt.type;\r\n            if (langx.isFunction(options[typ])) {\r\n                options[typ].call(fuInst._elm,evt,data);\r\n            }\r\n        });\r\n        return fuInst;\r\n    }\r\n\r\n    return filer.uploader = uploader;\r\n\r\n});\r\n\ndefine('skylark-utils-filer/main',[\r\n\t\"./filer\",\r\n\t\"./download\",\r\n\t\"./dropzone\",\r\n\t\"./pastezone\",\r\n\t\"./picker\",\r\n\t\"./read\",\r\n\t\"./select\",\r\n\t\"./upload\",\r\n\t\"./uploader\",\r\n\t\"./webentry\"\r\n],function(filer){\r\n\treturn filer;\r\n});\ndefine('skylark-utils-filer', ['skylark-utils-filer/main'], function (main) { return main; });\n\n"]}